{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { BehaviorSubject, Observable, Subject } from 'rxjs';\nimport { filter, share, take } from 'rxjs/operators';\nimport { Client } from '@stomp/stompjs';\nimport { RxStompState } from './rx-stomp-state';\n/**\n * This is the main Stomp Client.\n * Typically you will create an instance of this to connect to the STOMP broker.\n *\n * This wraps [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n * {@link Client} class.\n *\n * The key difference is that it exposes operations as RxJS Observables.\n * For example when a STOMP endpoint is subscribed it returns an Observable\n * that will stream all received messages.\n *\n * With exception of beforeConnect, functionality related to all callbacks in\n * [@stomp/stompjs Client]{@link Client}\n * is exposed as Observables/Subjects/BehaviorSubjects.\n *\n * RxStomp also tries to transparently handle connection failures.\n *\n * Part of `@stomp/rx-stomp`\n */\n\nexport class RxStomp {\n  /**\n   * Constructor\n   *\n   * @param stompClient optionally inject the\n   * [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n   * {@link Client} to wrap. If this is not provided, a client will\n   * be constructed internally.\n   */\n  constructor(stompClient) {\n    /**\n     * Internal array to hold locally queued messages when STOMP broker is not connected.\n     */\n    this._queuedMessages = [];\n    const client = stompClient ? stompClient : new Client();\n    this._stompClient = client;\n\n    const noOp = () => {}; // Before connect is no op by default\n\n\n    this._beforeConnect = noOp; // Correlate errors is falsey op by default\n\n    this._correlateErrors = () => undefined; // debug is no-op by default\n\n\n    this._debug = noOp; // Initial state is CLOSED\n\n    this._connectionStatePre$ = new BehaviorSubject(RxStompState.CLOSED);\n    this._connectedPre$ = this._connectionStatePre$.pipe(filter(currentState => {\n      return currentState === RxStompState.OPEN;\n    })); // Initial state is CLOSED\n\n    this.connectionState$ = new BehaviorSubject(RxStompState.CLOSED);\n    this.connected$ = this.connectionState$.pipe(filter(currentState => {\n      return currentState === RxStompState.OPEN;\n    })); // Setup sending queuedMessages\n\n    this.connected$.subscribe(() => {\n      this._sendQueuedMessages();\n    });\n    this._serverHeadersBehaviourSubject$ = new BehaviorSubject(null);\n    this.serverHeaders$ = this._serverHeadersBehaviourSubject$.pipe(filter(headers => {\n      return headers !== null;\n    }));\n    this.stompErrors$ = new Subject();\n    this.unhandledMessage$ = new Subject();\n    this.unhandledReceipts$ = new Subject();\n    this.unhandledFrame$ = new Subject();\n    this.webSocketErrors$ = new Subject();\n  }\n  /**\n   * Instance of actual\n   * [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n   * {@link Client}.\n   *\n   * **Be careful in calling methods on it directly - you may get unintended consequences.**\n   */\n\n\n  get stompClient() {\n    return this._stompClient;\n  }\n  /**\n   * Set configuration. This method may be called multiple times.\n   * Each call will add to the existing configuration.\n   *\n   * Example:\n   *\n   * ```javascript\n   *        const rxStomp = new RxStomp();\n   *        rxStomp.configure({\n   *          brokerURL: 'ws://127.0.0.1:15674/ws',\n   *          connectHeaders: {\n   *            login: 'guest',\n   *            passcode: 'guest'\n   *          },\n   *          heartbeatIncoming: 0,\n   *          heartbeatOutgoing: 20000,\n   *          reconnectDelay: 200,\n   *          debug: (msg: string): void => {\n   *            console.log(new Date(), msg);\n   *          }\n   *        });\n   *        rxStomp.activate();\n   * ```\n   *\n   * Maps to: [Client#configure]{@link Client#configure}\n   */\n\n\n  configure(rxStompConfig) {\n    const stompConfig = Object.assign({}, rxStompConfig);\n\n    if (stompConfig.beforeConnect) {\n      this._beforeConnect = stompConfig.beforeConnect;\n      delete stompConfig.beforeConnect;\n    }\n\n    if (stompConfig.correlateErrors) {\n      this._correlateErrors = stompConfig.correlateErrors;\n      delete stompConfig.correlateErrors;\n    } // RxStompConfig has subset of StompConfig fields\n\n\n    this._stompClient.configure(stompConfig);\n\n    if (stompConfig.debug) {\n      this._debug = stompConfig.debug;\n    }\n  }\n  /**\n   * Initiate the connection with the broker.\n   * If the connection breaks, as per [RxStompConfig#reconnectDelay]{@link RxStompConfig#reconnectDelay},\n   * it will keep trying to reconnect.\n   *\n   * Call [RxStomp#deactivate]{@link RxStomp#deactivate} to disconnect and stop reconnection attempts.\n   *\n   * Maps to: [Client#activate]{@link Client#activate}\n   */\n\n\n  activate() {\n    this._stompClient.configure({\n      beforeConnect: () => __awaiter(this, void 0, void 0, function* () {\n        this._changeState(RxStompState.CONNECTING); // Call handler\n\n\n        yield this._beforeConnect(this);\n      }),\n      onConnect: frame => {\n        this._serverHeadersBehaviourSubject$.next(frame.headers); // Indicate our connected state to observers\n\n\n        this._changeState(RxStompState.OPEN);\n      },\n      onStompError: frame => {\n        // Trigger the frame subject\n        this.stompErrors$.next(frame);\n      },\n      onWebSocketClose: () => {\n        this._changeState(RxStompState.CLOSED);\n      },\n      onUnhandledMessage: message => {\n        this.unhandledMessage$.next(message);\n      },\n      onUnhandledReceipt: frame => {\n        this.unhandledReceipts$.next(frame);\n      },\n      onUnhandledFrame: frame => {\n        this.unhandledFrame$.next(frame);\n      },\n      onWebSocketError: evt => {\n        this.webSocketErrors$.next(evt);\n      }\n    }); // Attempt connection\n\n\n    this._stompClient.activate();\n  }\n  /**\n   * Disconnect if connected and stop auto reconnect loop.\n   * Appropriate callbacks will be invoked if underlying STOMP connection was connected.\n   *\n   * To reactivate you can call [RxStomp#activate]{@link RxStomp#activate}.\n   *\n   * Maps to: [Client#deactivate]{@link Client#deactivate}\n   */\n\n\n  deactivate() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._changeState(RxStompState.CLOSING); // The promise will be resolved immediately if there are no active connection\n      // otherwise, after it has successfully disconnected.\n\n\n      yield this._stompClient.deactivate();\n\n      this._changeState(RxStompState.CLOSED);\n    });\n  }\n  /**\n   * It will return `true` if STOMP broker is connected and `false` otherwise.\n   */\n\n\n  connected() {\n    return this.connectionState$.getValue() === RxStompState.OPEN;\n  }\n  /**\n   * If the client is active (connected or going to reconnect).\n   *\n   *  Maps to: [Client#active]{@link Client#active}\n   */\n\n\n  get active() {\n    return this.stompClient.active;\n  }\n  /**\n   * Send a message to a named destination. Refer to your STOMP broker documentation for types\n   * and naming of destinations.\n   *\n   * STOMP protocol specifies and suggests some headers and also allows broker specific headers.\n   *\n   * `body` must be String.\n   * You will need to covert the payload to string in case it is not string (e.g. JSON).\n   *\n   * To send a binary message body use binaryBody parameter. It should be a\n   * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n   * Sometimes brokers may not support binary frames out of the box.\n   * Please check your broker documentation.\n   *\n   * `content-length` header is automatically added to the STOMP Frame sent to the broker.\n   * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\n   * For binary messages `content-length` header is always added.\n   *\n   * Caution: The broker will, most likely, report an error and disconnect if message body has NULL octet(s)\n   * and `content-length` header is missing.\n   *\n   * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n   * publish queued messages as soon as the broker gets connected.\n   * If you do not want that behavior,\n   * please set [retryIfDisconnected]{@link IRxStompPublishParams#retryIfDisconnected} to `false`\n   * in the parameters.\n   * When `false`, this function will raise an error if message could not be sent immediately.\n   *\n   * Maps to: [Client#publish]{@link Client#publish}\n   *\n   * See: {@link IRxStompPublishParams} and {@link IPublishParams}\n   *\n   * ```javascript\n   *        rxStomp.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\n   *\n   *        // Only destination is mandatory parameter\n   *        rxStomp.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\n   *\n   *        // Skip content-length header in the frame to the broker\n   *        rxStomp.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\n   *\n   *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\n   *        // setting content-type header is not mandatory, however a good practice\n   *        rxStomp.publish({destination: '/topic/special', binaryBody: binaryData,\n   *                         headers: {'content-type': 'application/octet-stream'}});\n   * ```\n   */\n\n\n  publish(parameters) {\n    // retry behaviour is defaulted to true\n    const shouldRetry = parameters.retryIfDisconnected == null ? true : parameters.retryIfDisconnected;\n\n    if (this.connected()) {\n      this._stompClient.publish(parameters);\n    } else if (shouldRetry) {\n      this._debug(`Not connected, queueing`);\n\n      this._queuedMessages.push(parameters);\n    } else {\n      throw new Error('Cannot publish while broker is not connected');\n    }\n  }\n  /** It will send queued messages. */\n\n\n  _sendQueuedMessages() {\n    const queuedMessages = this._queuedMessages;\n    this._queuedMessages = [];\n\n    if (queuedMessages.length === 0) {\n      return;\n    }\n\n    this._debug(`Will try sending  ${queuedMessages.length} queued message(s)`);\n\n    for (const queuedMessage of queuedMessages) {\n      this._debug(`Attempting to send ${queuedMessage}`);\n\n      this.publish(queuedMessage);\n    }\n  }\n\n  watch(opts, headers = {}) {\n    const defaults = {\n      subHeaders: {},\n      unsubHeaders: {},\n      subscribeOnlyOnce: false\n    };\n    let params;\n\n    if (typeof opts === 'string') {\n      params = Object.assign({}, defaults, {\n        destination: opts,\n        subHeaders: headers\n      });\n    } else {\n      params = Object.assign({}, defaults, opts);\n    }\n    /* Well the logic is complicated but works beautifully. RxJS is indeed wonderful.\n     *\n     * We need to activate the underlying subscription immediately if Stomp is connected. If not it should\n     * subscribe when it gets next connected. Further it should re establish the subscription whenever Stomp\n     * successfully reconnects.\n     *\n     * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\n     * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\n     *\n     * The observable that we return to caller remains same across all reconnects, so no special handling needed at\n     * the message subscriber.\n     */\n\n\n    this._debug(`Request to subscribe ${params.destination}`);\n\n    const coldObservable = Observable.create(messages => {\n      /*\n       * These variables will be used as part of the closure and work their magic during unsubscribe\n       */\n      let stompSubscription; // Stomp\n\n      let stompConnectedSubscription; // RxJS\n\n      let connectedPre$ = this._connectedPre$;\n\n      if (params.subscribeOnlyOnce) {\n        connectedPre$ = connectedPre$.pipe(take(1));\n      }\n\n      const stompErrorsSubscription = this.stompErrors$.subscribe(error => {\n        const correlatedDestination = this._correlateErrors(error);\n\n        if (correlatedDestination === params.destination) {\n          messages.error(error);\n        }\n      });\n      stompConnectedSubscription = connectedPre$.subscribe(() => {\n        this._debug(`Will subscribe to ${params.destination}`);\n\n        let subHeaders = params.subHeaders;\n\n        if (typeof subHeaders === 'function') {\n          subHeaders = subHeaders();\n        }\n\n        stompSubscription = this._stompClient.subscribe(params.destination, message => {\n          messages.next(message);\n        }, subHeaders);\n      });\n      return () => {\n        /* cleanup function, will be called when no subscribers are left */\n        this._debug(`Stop watching connection state (for ${params.destination})`);\n\n        stompConnectedSubscription.unsubscribe();\n        stompErrorsSubscription.unsubscribe();\n\n        if (this.connected()) {\n          this._debug(`Will unsubscribe from ${params.destination} at Stomp`);\n\n          let unsubHeaders = params.unsubHeaders;\n\n          if (typeof unsubHeaders === 'function') {\n            unsubHeaders = unsubHeaders();\n          }\n\n          stompSubscription.unsubscribe(unsubHeaders);\n        } else {\n          this._debug(`Stomp not connected, no need to unsubscribe from ${params.destination} at Stomp`);\n        }\n      };\n    });\n    /**\n     * Important - convert it to hot Observable - otherwise, if the user code subscribes\n     * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\n     * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n     */\n\n    return coldObservable.pipe(share());\n  }\n  /**\n   * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n   * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n   * The value (say receipt-id) for this header needs to be unique for each use. Typically a sequence, a UUID, a\n   * random number or a combination may be used.\n   *\n   * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n   * The operation needs to be matched based in the value of the receipt-id.\n   *\n   * This method allow watching for a receipt and invoke the callback\n   * when corresponding receipt has been received.\n   *\n   * The actual {@link Frame}\n   * will be passed as parameter to the callback.\n   *\n   * Example:\n   * ```javascript\n   *        // Publishing with acknowledgement\n   *        let receiptId = randomText();\n   *\n   *        rxStomp.watchForReceipt(receiptId, function() {\n   *          // Will be called after server acknowledges\n   *        });\n   *        rxStomp.publish({destination: '/topic/special', headers: {receipt: receiptId}, body: msg});\n   * ```\n   *\n   * Maps to: [Client#watchForReceipt]{@link Client#watchForReceipt}\n   */\n\n\n  watchForReceipt(receiptId, callback) {\n    this._stompClient.watchForReceipt(receiptId, callback);\n  }\n\n  _changeState(state) {\n    this._connectionStatePre$.next(state);\n\n    this.connectionState$.next(state);\n  }\n\n}","map":{"version":3,"sources":["E:/cultechconnect/CulTechConnectFrontOffice/node_modules/@stomp/rx-stomp/esm6/rx-stomp.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","BehaviorSubject","Observable","Subject","filter","share","take","Client","RxStompState","RxStomp","constructor","stompClient","_queuedMessages","client","_stompClient","noOp","_beforeConnect","_correlateErrors","undefined","_debug","_connectionStatePre$","CLOSED","_connectedPre$","pipe","currentState","OPEN","connectionState$","connected$","subscribe","_sendQueuedMessages","_serverHeadersBehaviourSubject$","serverHeaders$","headers","stompErrors$","unhandledMessage$","unhandledReceipts$","unhandledFrame$","webSocketErrors$","configure","rxStompConfig","stompConfig","Object","assign","beforeConnect","correlateErrors","debug","activate","_changeState","CONNECTING","onConnect","frame","onStompError","onWebSocketClose","onUnhandledMessage","message","onUnhandledReceipt","onUnhandledFrame","onWebSocketError","evt","deactivate","CLOSING","connected","getValue","active","publish","parameters","shouldRetry","retryIfDisconnected","push","Error","queuedMessages","length","queuedMessage","watch","opts","defaults","subHeaders","unsubHeaders","subscribeOnlyOnce","params","destination","coldObservable","create","messages","stompSubscription","stompConnectedSubscription","connectedPre$","stompErrorsSubscription","error","correlatedDestination","unsubscribe","watchForReceipt","receiptId","callback","state"],"mappings":"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","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BehaviorSubject, Observable, Subject, } from 'rxjs';\nimport { filter, share, take } from 'rxjs/operators';\nimport { Client, } from '@stomp/stompjs';\nimport { RxStompState } from './rx-stomp-state';\n/**\n * This is the main Stomp Client.\n * Typically you will create an instance of this to connect to the STOMP broker.\n *\n * This wraps [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n * {@link Client} class.\n *\n * The key difference is that it exposes operations as RxJS Observables.\n * For example when a STOMP endpoint is subscribed it returns an Observable\n * that will stream all received messages.\n *\n * With exception of beforeConnect, functionality related to all callbacks in\n * [@stomp/stompjs Client]{@link Client}\n * is exposed as Observables/Subjects/BehaviorSubjects.\n *\n * RxStomp also tries to transparently handle connection failures.\n *\n * Part of `@stomp/rx-stomp`\n */\nexport class RxStomp {\n    /**\n     * Constructor\n     *\n     * @param stompClient optionally inject the\n     * [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n     * {@link Client} to wrap. If this is not provided, a client will\n     * be constructed internally.\n     */\n    constructor(stompClient) {\n        /**\n         * Internal array to hold locally queued messages when STOMP broker is not connected.\n         */\n        this._queuedMessages = [];\n        const client = stompClient ? stompClient : new Client();\n        this._stompClient = client;\n        const noOp = () => { };\n        // Before connect is no op by default\n        this._beforeConnect = noOp;\n        // Correlate errors is falsey op by default\n        this._correlateErrors = () => undefined;\n        // debug is no-op by default\n        this._debug = noOp;\n        // Initial state is CLOSED\n        this._connectionStatePre$ = new BehaviorSubject(RxStompState.CLOSED);\n        this._connectedPre$ = this._connectionStatePre$.pipe(filter((currentState) => {\n            return currentState === RxStompState.OPEN;\n        }));\n        // Initial state is CLOSED\n        this.connectionState$ = new BehaviorSubject(RxStompState.CLOSED);\n        this.connected$ = this.connectionState$.pipe(filter((currentState) => {\n            return currentState === RxStompState.OPEN;\n        }));\n        // Setup sending queuedMessages\n        this.connected$.subscribe(() => {\n            this._sendQueuedMessages();\n        });\n        this._serverHeadersBehaviourSubject$ =\n            new BehaviorSubject(null);\n        this.serverHeaders$ = this._serverHeadersBehaviourSubject$.pipe(filter((headers) => {\n            return headers !== null;\n        }));\n        this.stompErrors$ = new Subject();\n        this.unhandledMessage$ = new Subject();\n        this.unhandledReceipts$ = new Subject();\n        this.unhandledFrame$ = new Subject();\n        this.webSocketErrors$ = new Subject();\n    }\n    /**\n     * Instance of actual\n     * [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n     * {@link Client}.\n     *\n     * **Be careful in calling methods on it directly - you may get unintended consequences.**\n     */\n    get stompClient() {\n        return this._stompClient;\n    }\n    /**\n     * Set configuration. This method may be called multiple times.\n     * Each call will add to the existing configuration.\n     *\n     * Example:\n     *\n     * ```javascript\n     *        const rxStomp = new RxStomp();\n     *        rxStomp.configure({\n     *          brokerURL: 'ws://127.0.0.1:15674/ws',\n     *          connectHeaders: {\n     *            login: 'guest',\n     *            passcode: 'guest'\n     *          },\n     *          heartbeatIncoming: 0,\n     *          heartbeatOutgoing: 20000,\n     *          reconnectDelay: 200,\n     *          debug: (msg: string): void => {\n     *            console.log(new Date(), msg);\n     *          }\n     *        });\n     *        rxStomp.activate();\n     * ```\n     *\n     * Maps to: [Client#configure]{@link Client#configure}\n     */\n    configure(rxStompConfig) {\n        const stompConfig = Object.assign({}, rxStompConfig);\n        if (stompConfig.beforeConnect) {\n            this._beforeConnect = stompConfig.beforeConnect;\n            delete stompConfig.beforeConnect;\n        }\n        if (stompConfig.correlateErrors) {\n            this._correlateErrors = stompConfig.correlateErrors;\n            delete stompConfig.correlateErrors;\n        }\n        // RxStompConfig has subset of StompConfig fields\n        this._stompClient.configure(stompConfig);\n        if (stompConfig.debug) {\n            this._debug = stompConfig.debug;\n        }\n    }\n    /**\n     * Initiate the connection with the broker.\n     * If the connection breaks, as per [RxStompConfig#reconnectDelay]{@link RxStompConfig#reconnectDelay},\n     * it will keep trying to reconnect.\n     *\n     * Call [RxStomp#deactivate]{@link RxStomp#deactivate} to disconnect and stop reconnection attempts.\n     *\n     * Maps to: [Client#activate]{@link Client#activate}\n     */\n    activate() {\n        this._stompClient.configure({\n            beforeConnect: () => __awaiter(this, void 0, void 0, function* () {\n                this._changeState(RxStompState.CONNECTING);\n                // Call handler\n                yield this._beforeConnect(this);\n            }),\n            onConnect: (frame) => {\n                this._serverHeadersBehaviourSubject$.next(frame.headers);\n                // Indicate our connected state to observers\n                this._changeState(RxStompState.OPEN);\n            },\n            onStompError: (frame) => {\n                // Trigger the frame subject\n                this.stompErrors$.next(frame);\n            },\n            onWebSocketClose: () => {\n                this._changeState(RxStompState.CLOSED);\n            },\n            onUnhandledMessage: (message) => {\n                this.unhandledMessage$.next(message);\n            },\n            onUnhandledReceipt: (frame) => {\n                this.unhandledReceipts$.next(frame);\n            },\n            onUnhandledFrame: (frame) => {\n                this.unhandledFrame$.next(frame);\n            },\n            onWebSocketError: (evt) => {\n                this.webSocketErrors$.next(evt);\n            },\n        });\n        // Attempt connection\n        this._stompClient.activate();\n    }\n    /**\n     * Disconnect if connected and stop auto reconnect loop.\n     * Appropriate callbacks will be invoked if underlying STOMP connection was connected.\n     *\n     * To reactivate you can call [RxStomp#activate]{@link RxStomp#activate}.\n     *\n     * Maps to: [Client#deactivate]{@link Client#deactivate}\n     */\n    deactivate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._changeState(RxStompState.CLOSING);\n            // The promise will be resolved immediately if there are no active connection\n            // otherwise, after it has successfully disconnected.\n            yield this._stompClient.deactivate();\n            this._changeState(RxStompState.CLOSED);\n        });\n    }\n    /**\n     * It will return `true` if STOMP broker is connected and `false` otherwise.\n     */\n    connected() {\n        return this.connectionState$.getValue() === RxStompState.OPEN;\n    }\n    /**\n     * If the client is active (connected or going to reconnect).\n     *\n     *  Maps to: [Client#active]{@link Client#active}\n     */\n    get active() {\n        return this.stompClient.active;\n    }\n    /**\n     * Send a message to a named destination. Refer to your STOMP broker documentation for types\n     * and naming of destinations.\n     *\n     * STOMP protocol specifies and suggests some headers and also allows broker specific headers.\n     *\n     * `body` must be String.\n     * You will need to covert the payload to string in case it is not string (e.g. JSON).\n     *\n     * To send a binary message body use binaryBody parameter. It should be a\n     * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n     * Sometimes brokers may not support binary frames out of the box.\n     * Please check your broker documentation.\n     *\n     * `content-length` header is automatically added to the STOMP Frame sent to the broker.\n     * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\n     * For binary messages `content-length` header is always added.\n     *\n     * Caution: The broker will, most likely, report an error and disconnect if message body has NULL octet(s)\n     * and `content-length` header is missing.\n     *\n     * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n     * publish queued messages as soon as the broker gets connected.\n     * If you do not want that behavior,\n     * please set [retryIfDisconnected]{@link IRxStompPublishParams#retryIfDisconnected} to `false`\n     * in the parameters.\n     * When `false`, this function will raise an error if message could not be sent immediately.\n     *\n     * Maps to: [Client#publish]{@link Client#publish}\n     *\n     * See: {@link IRxStompPublishParams} and {@link IPublishParams}\n     *\n     * ```javascript\n     *        rxStomp.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\n     *\n     *        // Only destination is mandatory parameter\n     *        rxStomp.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\n     *\n     *        // Skip content-length header in the frame to the broker\n     *        rxStomp.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\n     *\n     *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\n     *        // setting content-type header is not mandatory, however a good practice\n     *        rxStomp.publish({destination: '/topic/special', binaryBody: binaryData,\n     *                         headers: {'content-type': 'application/octet-stream'}});\n     * ```\n     */\n    publish(parameters) {\n        // retry behaviour is defaulted to true\n        const shouldRetry = parameters.retryIfDisconnected == null\n            ? true\n            : parameters.retryIfDisconnected;\n        if (this.connected()) {\n            this._stompClient.publish(parameters);\n        }\n        else if (shouldRetry) {\n            this._debug(`Not connected, queueing`);\n            this._queuedMessages.push(parameters);\n        }\n        else {\n            throw new Error('Cannot publish while broker is not connected');\n        }\n    }\n    /** It will send queued messages. */\n    _sendQueuedMessages() {\n        const queuedMessages = this._queuedMessages;\n        this._queuedMessages = [];\n        if (queuedMessages.length === 0) {\n            return;\n        }\n        this._debug(`Will try sending  ${queuedMessages.length} queued message(s)`);\n        for (const queuedMessage of queuedMessages) {\n            this._debug(`Attempting to send ${queuedMessage}`);\n            this.publish(queuedMessage);\n        }\n    }\n    watch(opts, headers = {}) {\n        const defaults = {\n            subHeaders: {},\n            unsubHeaders: {},\n            subscribeOnlyOnce: false,\n        };\n        let params;\n        if (typeof opts === 'string') {\n            params = Object.assign({}, defaults, {\n                destination: opts,\n                subHeaders: headers,\n            });\n        }\n        else {\n            params = Object.assign({}, defaults, opts);\n        }\n        /* Well the logic is complicated but works beautifully. RxJS is indeed wonderful.\n         *\n         * We need to activate the underlying subscription immediately if Stomp is connected. If not it should\n         * subscribe when it gets next connected. Further it should re establish the subscription whenever Stomp\n         * successfully reconnects.\n         *\n         * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\n         * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\n         *\n         * The observable that we return to caller remains same across all reconnects, so no special handling needed at\n         * the message subscriber.\n         */\n        this._debug(`Request to subscribe ${params.destination}`);\n        const coldObservable = Observable.create((messages) => {\n            /*\n             * These variables will be used as part of the closure and work their magic during unsubscribe\n             */\n            let stompSubscription; // Stomp\n            let stompConnectedSubscription; // RxJS\n            let connectedPre$ = this._connectedPre$;\n            if (params.subscribeOnlyOnce) {\n                connectedPre$ = connectedPre$.pipe(take(1));\n            }\n            const stompErrorsSubscription = this.stompErrors$.subscribe((error) => {\n                const correlatedDestination = this._correlateErrors(error);\n                if (correlatedDestination === params.destination) {\n                    messages.error(error);\n                }\n            });\n            stompConnectedSubscription = connectedPre$.subscribe(() => {\n                this._debug(`Will subscribe to ${params.destination}`);\n                let subHeaders = params.subHeaders;\n                if (typeof subHeaders === 'function') {\n                    subHeaders = subHeaders();\n                }\n                stompSubscription = this._stompClient.subscribe(params.destination, (message) => {\n                    messages.next(message);\n                }, subHeaders);\n            });\n            return () => {\n                /* cleanup function, will be called when no subscribers are left */\n                this._debug(`Stop watching connection state (for ${params.destination})`);\n                stompConnectedSubscription.unsubscribe();\n                stompErrorsSubscription.unsubscribe();\n                if (this.connected()) {\n                    this._debug(`Will unsubscribe from ${params.destination} at Stomp`);\n                    let unsubHeaders = params.unsubHeaders;\n                    if (typeof unsubHeaders === 'function') {\n                        unsubHeaders = unsubHeaders();\n                    }\n                    stompSubscription.unsubscribe(unsubHeaders);\n                }\n                else {\n                    this._debug(`Stomp not connected, no need to unsubscribe from ${params.destination} at Stomp`);\n                }\n            };\n        });\n        /**\n         * Important - convert it to hot Observable - otherwise, if the user code subscribes\n         * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\n         * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n         */\n        return coldObservable.pipe(share());\n    }\n    /**\n     * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n     * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n     * The value (say receipt-id) for this header needs to be unique for each use. Typically a sequence, a UUID, a\n     * random number or a combination may be used.\n     *\n     * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n     * The operation needs to be matched based in the value of the receipt-id.\n     *\n     * This method allow watching for a receipt and invoke the callback\n     * when corresponding receipt has been received.\n     *\n     * The actual {@link Frame}\n     * will be passed as parameter to the callback.\n     *\n     * Example:\n     * ```javascript\n     *        // Publishing with acknowledgement\n     *        let receiptId = randomText();\n     *\n     *        rxStomp.watchForReceipt(receiptId, function() {\n     *          // Will be called after server acknowledges\n     *        });\n     *        rxStomp.publish({destination: '/topic/special', headers: {receipt: receiptId}, body: msg});\n     * ```\n     *\n     * Maps to: [Client#watchForReceipt]{@link Client#watchForReceipt}\n     */\n    watchForReceipt(receiptId, callback) {\n        this._stompClient.watchForReceipt(receiptId, callback);\n    }\n    _changeState(state) {\n        this._connectionStatePre$.next(state);\n        this.connectionState$.next(state);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}